# Semantic Analysis

# 프로젝트 개요
이 프로젝트는 input C 코드가 의미에 부합하는지를 확인하는 과정입니다. 

이 프로젝트는 다음의 5가지 Semantic Error를 중점적으로 탐지합니다
- **Undeclared Variables & Functions**  
  선언되지 않은 식별자의 사용 여부 탐지
- **Re-declaration**  
  동일 스코프 내 중복 선언 탐지
- **Type Checking**  
  대입, 연산, 함수 호출 시 타입 불일치 검출
- **Structure & Structure Pointer Declaration**  
  구조체 정의 전 사용, 구조체 멤버 접근 오류 검출
- **Function Declaration**  
  함수 선언/정의의 일관성, 파라미터 및 반환 타입 오류 탐지

이 논리 구조를 기준으로 **Semantic Analysis의 커버리지를 판단**합니다.
<br><br>

# 실제 구현 흐름
다만, 위의 과정에서는 오류를 탐색하는 과정이기 때문에 다음과 같은 구현 과정으로 하나씩 진행합니다.

### 1단계. 심볼 테이블 & 스코프 시스템

| **작업 ID** | **구현 요소**                                   | **설명**                    |
| --------- | ------------------------------------------- | ------------------------- |
| 1-1       | `Symbol`, `SymbolTable`, `current_scope` 정의 | 각 식별자와 스코프를 표현할 수 있도록     |
| 1-2       | `push_scope()`, `pop_scope()` 구현            | `{}` 혹은 함수 정의 등에서 스코프 이동  |
| 1-3       | `insert_symbol()` 구현                        | 선언 시 심볼 삽입, 중복 선언 검사 포함   |
| 1-4       | `lookup_symbol()` 구현                        | 사용 시 스코프 체인을 따라 심볼 탐색     |
| 1-5       | 테스트: 단일 스코프 내 insert/lookup 동작 확인           | 간단한 `main()` or 테스트 yacc로 |

---

### 2단계. subc.y에 선언 연동 및 중복 검사

| **작업 ID** | **구현 요소**                                       | **설명**                             |
| --------- | ----------------------------------------------- | ---------------------------------- |
| 2-1       | `subc.y`의 `def`, `ext_def` 등에서 insert_symbol 호출 | 선언문에서 이름 등록                        |
| 2-2       | 중복 선언이면 에러 메시지 출력 (instruction 45번)             | `error_redeclared_identifier()` 사용 |
| 2-3       | 간단한 테스트 코드로 변수 중복 선언 확인                         | `int x; int x;` 등                  |

---

### 3단계. undeclared 탐지 및 에러 처리

| **작업 ID** | **구현 요소**                               | **설명**          |
| --------- | --------------------------------------- | --------------- |
| 3-1       | `ID`, `primary_expr` 등에서 lookup 호출      | 사용된 변수 탐색       |
| 3-2       | 못 찾으면 에러 출력 + `$$ = NULL` 할당            | 이후 propagate 위해 |
| 3-3       | propagate: `if ($1 == NULL)`로 action 생략 | 오류 이후 흐름 방지     |

---

### 4단계. 타입 시스템 기본 구축 + 대입 검사

| **작업 ID** | **구현 요소**              | **설명**                                                 |
| --------- | ---------------------- | ------------------------------------------------------ |
| 4-1       | `TypeInfo` 구조체 설계      | int, char, pointer, array, struct                      |
| 4-2       | `is_same_type()` 구현    | 기본 타입만 먼저 비교                                           |
| 4-3       | 대입문 타입 검사: `a = b`     | 타입 다르면 에러 (`error_incompatible_types_in_assignment()`) |
| 4-4       | lvalue 확인: 상수, 배열 이름 등 | assign 가능하지 않으면 에러 출력                                  |

---

### 5단계. 스코프 확장: 블록 / 함수 처리

| **작업 ID** | **구현 요소**                                     | **설명**              |
| --------- | --------------------------------------------- | ------------------- |
| 5-1       | `{}` 진입 시 `push_scope()` 호출                   | `compound_stmt` 등에서 |
| 5-2       | `}` 종료 시 `pop_scope()` 호출                     | 블록 탈출 시             |
| 5-3       | `func_def`에서도 블록과 동일하게 처리                     | 파라미터/로컬 변수 분리       |
| 5-4       | 테스트: `{ int x; { char x; } }` → inner가 우선 적용됨 |                     |

---

### 6단계. 구조체 정의 및 멤버 탐색 처리

| **작업 ID** | **구현 요소**                                       | **설명**                  |
| --------- | ----------------------------------------------- | ----------------------- |
| 6-1       | `struct_specifier` 처리: 새 스코프 → 필드 수집            | FieldInfo로 정리           |
| 6-2       | 구조체 타입: `TypeInfo`에 struct name + field list 저장 | 필드 리스트 연결 구조로           |
| 6-3       | global type list 관리 → 중복 정의 검사                  | 기존 struct 이름 존재 시 에러 출력 |
| 6-4       | 구조체 멤버 접근: `a.b`, `a->b` → 타입 확인 + 필드 탐색        | 잘못된 접근 시 에러             |

---

### 7단계. 타입 검사 확장 — 연산자, 함수, array 등

| **작업 ID** | **구현 요소**                           | **설명**                   |
| --------- | ----------------------------------- | ------------------------ |
| 7-1       | 산술/논리 연산자 타입 체크: `+`, `==`, `&&`, 등 | int만 허용하거나 타입 일치 필수      |
| 7-2       | 포인터 연산: `*`, `&`, `NULL` 처리         | NULL 할당 검사               |
| 7-3       | 배열 연산: `a[i]` 등 검사                  | 배열 타입 + index 타입 int     |
| 7-4       | 함수 정의 시 FuncInfo 등록, 중복 검사          | global_func_list에 등록     |
| 7-5       | 함수 호출 시 인자 타입 비교                    | parameter type과 일치 여부 검사 |
| 7-6       | return문의 타입 검사                      | 반환 타입과 선언된 반환 타입 비교      |

---

### 8단계. 에러 출력 및 메모리 정리

| **작업 ID** | **구현 요소**                                     | **설명**                          |
| --------- | --------------------------------------------- | ------------------------------- |
| 8-1       | 에러 메시지 출력 형식 구현                               | `filename:line_num: error: ...` |
| 8-2       | `error_preamble()` 함수 수정 → 파일 이름 + 줄 번호 출력    | `get_lineno()` + argv[1] 활용     |
| 8-3       | 각 스코프 pop 시 심볼 메모리 해제                         | `pop_scope()` 내에서 수행            |
| 8-4       | 전체 종료 시 global_func_list, global_type_list 해제 | memory leak 방지 + Asan 대응        |

